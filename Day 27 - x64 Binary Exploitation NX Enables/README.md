Resources used : https://www.youtube.com/watch?v=gxU3e7GbC-M : x64 Linux Binary Exploitation Training : Souce Meets Sink | https://www.theoffensivelabs.com/p/x64-linux-binary-exploitation-live-training 

NX Protection means : Not Executable stack which means anything in the stack wont be executable for us and we would have to use the stuff inside the binary or being used by the binary to succeced in our objective.
In NX basically the stack address does not have executable permissions to see it if you run the binary and do vmmap you can see the perms on the stack and it would say rw- making it NX enabled and not executable so any shellcode put in the stack wont be executed/excetuable.

Options to bypass this : Dont use stack for execution or stack executable again and execute your shellcode then.

First and most common one is RET2LIBC which is a library that is used by binaries written in C to execute stuff and we can point to an address in here. Ideally if there is a system function used it calls in libc and ideally the first arguement gets into RDI regsiter and in general first 6 arguements are placed in registers and if there are more then 6 arguements then they are placed on the stack. You can check which registers your arguement is in by doing 
```bash
info registers
```

For Return to Libc we can form our payload somewhat like this first we have junk till we reach the RIP then we overwite the RIP with POP RDI, RET gadget and with NX we have to always have gadgets that have RET at the because to bypass NX we have to execute our code using Return oriented programming and after we have overwritten the RIP with POP RDI, RET we then overwrite the RSP with addres of /bin/sh then address of system , and then address of exit.
All our gadgets have to end with RET at the end as when ret is called whatever value is on the top of stack is loaded in the RIP register .

Here is a visual representation of how this would look : 

Taken from the presentation linked in resources ( Not Mine ).

To find such gadgets we can use ropper and this tool is specialized in helping us find this.  And as we wanna find gadgets in libc we can copy the libc being used in the binary we can find the path of libc by doing vmmap on the binary in gdb and then using ropper like so :

```
ropper
file libc_file
search /1/ pop rdi # But this will only give us the offset of this libc
```

So now we will have libc offset and we will need to add it to the libc base address and now in our address we will have to add the offset to libc_base. Locally we can get the libc base by using vmmap. 

Now we would need to find the system and /bin/bash , to find the system addrss in gdb we can use xinfo system. And for finding /bin/bash we can use ropper or find it using strings like so :
```
strings -a -t x libc_file | grep "/bin/bash"
```

and we can then forge and exploit with this values but sometimes this wont work out of the gate due to issues of system function and stack alignment and to solve this sometimes we can use ret instruction first soemtimes before the pop rdi; ret gadget

Also it is recommended to provide to exit function as if you dont specify it then when you try to exit the shell it wont know where to refer it to and give us a seg fault and not exit very smoothly.

BTW This will only work when ASLR is disabled . 
